Decoder
  - decoder.Input ([]byte) -> decoder.Message
  - has line parser, Matcher
  - matches, then parses

LineParser
  - possibly recombines lines, if parser supports partial lines

Parser
  - line -> content/severity/timestamp/partial/error
  - EncodedText just decodes strings
  - docker_File decodes JSON

Matcher
  - bizarre API used to end lines

File Tailer
 - takes decoder
 - "forwards" decoder.Message from decoder to outputChan

+-Tailer---------------
|          * reading (socket, file)
|          | []byte buffers
|  +-Decoder-----------
|  |       |
|  |    Matcher
|  |       | []byte lines
|  |  +-LineParser-----
|  |  |    |
|  |  |  Parser
|  |  |    | (content, severity, timestamp, partial, error)
|  |  +----------------
|  |       |
|  +-------------------
|          | decoder.Message
|          |
|          * add origin
|          |
|          | message.Message
+----------------------
           |
       outputChan

# TODO

this PR
 * move line_parser code (multi's flushing etc.) into parsers, either as a way
   to wrap another Parser or as utility for Parsers
 * parsers README

for planning
 * line handler in above diagram?
 * what is Origin.Offset?  Audit tracking?

# Timestamps

It appears that parser.Message#Timestamp is ignored, as it is never included
in a message.Message -- to verify

parsers
 - docker_file -> from JSON (2019-06-06T16:35:55.930852911Z)
 - docker_stream -> from message (binary encoding) (2018-06-14T18:27:03.246999277Z)
 - encodedtext -> ""
 - kubernetes -> from message (space-sep) (2018-09-20T11:54:11.753589172Z)
 - noop -> ""

line parsers
 - single-line - hand to lineHandler.Handle
 - multi-line - hand to lineHandler.Handle

line handlers
 - auto-multi-line - hand to processingFunc
 - multiline - aggregated(ish) and handed to decoder.NewMessage
 - single-line - just hand off to outputChan

tailers
 - docker - used to track last-since (parsed with config.DateFormat)
          - included in origin.Offset
 - file - ignored
 - socket - ignored

# IsPartial

parser.Message#IsPartial appears to be about _one_ kind of multi-line parsing,
from docker's and k8s's JSON format, where a single line of output maybe sent
in JSON-wrapped "chunks", each on one line (of JSON) (confirmed by Brian)
