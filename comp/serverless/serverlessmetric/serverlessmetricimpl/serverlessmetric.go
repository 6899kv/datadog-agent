// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2023-present Datadog, Inc.

package serverlessmetricimpl

import (
	"os"
	"strings"
	"time"

	"go.uber.org/fx"

	dogstatsdServer "github.com/DataDog/datadog-agent/comp/dogstatsd/server"
	"github.com/DataDog/datadog-agent/comp/serverless/serverlessmetric"
	"github.com/DataDog/datadog-agent/pkg/aggregator"
	"github.com/DataDog/datadog-agent/pkg/config"
	"github.com/DataDog/datadog-agent/pkg/config/model"
	"github.com/DataDog/datadog-agent/pkg/config/utils"
	"github.com/DataDog/datadog-agent/pkg/util/fxutil"
	"github.com/DataDog/datadog-agent/pkg/util/log"
)

const (
	statsDMetricBlocklistKey = "statsd_metric_blocklist"
	proxyEnabledEnvVar       = "DD_EXPERIMENTAL_ENABLE_PROXY"
)

// TODO: combine with enhanced_metrics.go
const (
	// Latest Lambda pricing per https://aws.amazon.com/lambda/pricing/
	baseLambdaInvocationPrice = 0.0000002
	x86LambdaPricePerGbSecond = 0.0000166667
	armLambdaPricePerGbSecond = 0.0000133334
	msToSec                   = 0.001

	// Enhanced metrics
	maxMemoryUsedMetric       = "aws.lambda.enhanced.max_memory_used"
	memorySizeMetric          = "aws.lambda.enhanced.memorysize"
	runtimeDurationMetric     = "aws.lambda.enhanced.runtime_duration"
	billedDurationMetric      = "aws.lambda.enhanced.billed_duration"
	durationMetric            = "aws.lambda.enhanced.duration"
	postRuntimeDurationMetric = "aws.lambda.enhanced.post_runtime_duration"
	estimatedCostMetric       = "aws.lambda.enhanced.estimated_cost"
	initDurationMetric        = "aws.lambda.enhanced.init_duration"
	responseLatencyMetric     = "aws.lambda.enhanced.response_latency"
	responseDurationMetric    = "aws.lambda.enhanced.response_duration"
	producedBytesMetric       = "aws.lambda.enhanced.produced_bytes"
	// OutOfMemoryMetric is the name of the out of memory enhanced Lambda metric
	OutOfMemoryMetric = "aws.lambda.enhanced.out_of_memory"
	timeoutsMetric    = "aws.lambda.enhanced.timeouts"
	// ErrorsMetric is the name of the errors enhanced Lambda metric
	ErrorsMetric          = "aws.lambda.enhanced.errors"
	invocationsMetric     = "aws.lambda.enhanced.invocations"
	enhancedMetricsEnvVar = "DD_ENHANCED_METRICS"
)

type Params struct {
	SketchesBucketOffset time.Duration
}

type dependencies struct {
	fx.In
	Lc fx.Lifecycle

	Params Params
}

// ServerlessMetricAgent represents the DogStatsD server and the aggregator
type ServerlessMetricAgent struct {
	Demux                aggregator.Demultiplexer
	dogStatsDServer      dogstatsdServer.Component
	sketchesBucketOffset time.Duration
	tags                 []string
}

func newServerlessMetricAgent(deps dependencies) serverlessmetric.Component {
	// prevents any UDP packets from being stuck in the buffer and not parsed during the current invocation
	// by setting this option to 1ms, all packets received will directly be sent to the parser
	config.Datadog.Set("dogstatsd_packet_buffer_flush_timeout", 1*time.Millisecond, model.SourceAgentRuntime)

	// the invocation metric is also generated by Lambda Layers
	// we want to avoid duplicate metric
	customerList := config.Datadog.GetStringSlice(statsDMetricBlocklistKey)

	// if the proxy is enabled we need to also block the errorMetric
	if strings.ToLower(os.Getenv(proxyEnabledEnvVar)) == "true" {
		config.Datadog.Set(statsDMetricBlocklistKey, buildMetricBlocklistForProxy(customerList), model.SourceAgentRuntime)
	} else {
		config.Datadog.Set(statsDMetricBlocklistKey, buildMetricBlocklist(customerList), model.SourceAgentRuntime)
	}

	serverlessMetricAgent := &ServerlessMetricAgent{
		Demux:                buildDemultiplexer(deps.Params.SketchesBucketOffset),
		sketchesBucketOffset: deps.Params.SketchesBucketOffset,
		tags:                 []string{},
	}

	return serverlessMetricAgent
}

func (c *ServerlessMetricAgent) Start() {
	if c.Demux != nil {
		statsd := dogstatsdServer.NewServerlessServer()
		err := statsd.Start(c.Demux)
		if err != nil {
			log.Errorf("Unable to start the DogStatsD server: %s", err)
		} else {
			c.dogStatsDServer = statsd
		}
	}
}

// Stop stops the DogStatsD server
func (c *ServerlessMetricAgent) Stop() {
	if c.IsReady() {
		c.dogStatsDServer.Stop()
	}
}

// IsReady indicates whether or not the DogStatsD server is ready
func (c *ServerlessMetricAgent) IsReady() bool {
	return c.dogStatsDServer != nil
}

// Flush triggers a DogStatsD flush
func (c *ServerlessMetricAgent) Flush() {
	if c.IsReady() {
		c.dogStatsDServer.ServerlessFlush(c.sketchesBucketOffset)
	}
}

// SetExtraTags sets extra tags on the DogStatsD server
func (c *ServerlessMetricAgent) SetExtraTags(tagArray []string) {
	if c.IsReady() {
		c.tags = tagArray
		c.dogStatsDServer.SetExtraTags(tagArray)
	}
}

// GetExtraTags gets extra tags
func (c *ServerlessMetricAgent) GetExtraTags() []string {
	return c.tags
}

func buildDemultiplexer(forwarderTimeout time.Duration) aggregator.Demultiplexer {
	log.Debugf("Using a SyncForwarder with a %v timeout", forwarderTimeout)
	keysPerDomain, err := utils.GetMultipleEndpoints(config.Datadog)
	if err != nil {
		log.Errorf("Misconfiguration of agent endpoints: %s", err)
		return nil
	}
	return aggregator.InitAndStartServerlessDemultiplexer(keysPerDomain, forwarderTimeout)
}

func buildMetricBlocklist(userProvidedList []string) []string {
	return append(userProvidedList, invocationsMetric)
}

// Need to account for duplicate metrics when using the proxy.
func buildMetricBlocklistForProxy(userProvidedList []string) []string {
	return append(buildMetricBlocklist(userProvidedList), ErrorsMetric)
}

// Module defines the fx options for this component.
var Module = fxutil.Component(
	fx.Provide(newServerlessMetricAgent),
)
